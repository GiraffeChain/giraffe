// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.0.3
//   protoc               v3.21.12
// source: models/core.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../google/protobuf/struct.js";
import { StringValue, UInt32Value } from "../google/protobuf/wrappers.js";

export const protobufPackage = "com.giraffechain.models";

export interface BlockId {
  /** Base58 encoded */
  value: string;
}

/** Captures a block producer's consensus-commitment to a new block */
export interface BlockHeader {
  /**
   * The ID of _this_ block header.  This value is optional and its contents are not included in the signable or identifiable data.  Clients which _can_ verify
   * this value should verify this value, but some clients may not be able to or need to, in which case this field acts as a convenience.
   */
  headerId:
    | BlockId
    | undefined;
  /** The parent block's ID.  Each header builds from a single parent. */
  parentHeaderId:
    | BlockId
    | undefined;
  /**
   * The commitment/accumulator of the block body
   * length = 32
   */
  txRoot: string;
  /** The UTC UNIX timestamp (ms) when the block was created */
  timestamp: number;
  /** The 1-based index of this block in the blockchain */
  height: number;
  /** The time-slot in which the block producer created the block */
  slot: number;
  /** A certificate indicating that the block producer was eligible to make this block */
  stakerCertificate:
    | StakerCertificate
    | undefined;
  /** The operator's staking account location */
  account:
    | TransactionOutputReference
    | undefined;
  /** Configuration or protocol changes */
  settings: { [key: string]: string };
}

export interface BlockHeader_SettingsEntry {
  key: string;
  value: string;
}

/** A certificate proving the operator's election */
export interface StakerCertificate {
  /**
   * Signs the block
   * Base58 encoded
   * length = 64
   */
  blockSignature: string;
  /**
   * Signs `eta ++ slot` using the `vrfSK`
   * Base58 encoded
   * length = 80
   */
  vrfSignature: string;
  /**
   * The VRF VK
   * Base58 encoded
   * length = 32
   */
  vrfVK: string;
  /**
   * The epoch's randomness
   * Base58 encoded
   * length = 32
   */
  eta: string;
}

/** A glorified tuple */
export interface SlotId {
  /** The slot in which a block was created */
  slot: number;
  /** The ID of the block */
  blockId: BlockId | undefined;
}

/** Captures the ordering of transaction IDs within a block */
export interface BlockBody {
  /** A list of Transaction IDs included in this block */
  transactionIds: TransactionId[];
}

/** Captures the ordering of transactions (not just IDs) within a block */
export interface FullBlockBody {
  /** A list of Transactions included in this block */
  transactions: Transaction[];
}

/** Captures the header and all transactions in a block */
export interface Block {
  /** The block's header */
  header:
    | BlockHeader
    | undefined;
  /** The block's body */
  body: BlockBody | undefined;
}

/** Captures the header and all transactions in a block */
export interface FullBlock {
  /** The block's header */
  header:
    | BlockHeader
    | undefined;
  /** The block's full body */
  fullBody: FullBlockBody | undefined;
}

/** Represents the identifier of a Transction.  It is constructed from the evidence of the signable bytes of the Transaction. */
export interface TransactionId {
  /**
   * The evidence of the Transaction's signable bytes
   * Base58 encoded
   * length = 32
   */
  value: string;
}

export interface Transaction {
  transactionId:
    | TransactionId
    | undefined;
  /** If this is a reward transaction, this field should be empty */
  inputs: TransactionInput[];
  outputs: TransactionOutput[];
  attestation: Witness[];
  /**
   * User transactions should leave this empty.
   * When not null, this Transaction is assumed to be a reward transaction, and the value of this field should be the parent block ID
   */
  rewardParentBlockId: BlockId | undefined;
}

export interface TransactionConfirmation {
  height: number;
  depth: number;
}

export interface Witness {
  lockAddress: LockAddress | undefined;
  lock: Lock | undefined;
  key: Key | undefined;
}

export interface TransactionInput {
  reference: TransactionOutputReference | undefined;
}

export interface TransactionOutputReference {
  /** Required in _most_ cases. When not provided, acts as a reference to the "current" transaction. */
  transactionId: TransactionId | undefined;
  index: number;
}

export interface TransactionOutput {
  lockAddress: LockAddress | undefined;
  quantity: number;
  account: TransactionOutputReference | undefined;
  graphEntry: GraphEntry | undefined;
  accountRegistration: AccountRegistration | undefined;
  asset: Asset | undefined;
}

export interface AccountRegistration {
  associationLock:
    | LockAddress
    | undefined;
  /** Optional.  If provided, introduces a new staker to the chain. */
  stakingRegistration: StakingRegistration | undefined;
}

/** A proof-of-stake registration */
export interface StakingRegistration {
  /**
   * Ed25519 Signature of the VRF VK that is stamped on each header
   * Base58 encoded
   * length = 64
   */
  commitmentSignature: string;
  /**
   * Ed25519
   * Base58 encoded
   * length = 32
   */
  vk: string;
}

export interface GraphEntry {
  vertex?: Vertex | undefined;
  edge?: Edge | undefined;
}

export interface Vertex {
  label: string;
  data: { [key: string]: any } | undefined;
  edgeLockAddress: LockAddress | undefined;
}

export interface Edge {
  label: string;
  data: { [key: string]: any } | undefined;
  a: TransactionOutputReference | undefined;
  b: TransactionOutputReference | undefined;
}

export interface Asset {
  origin: TransactionOutputReference | undefined;
  quantity: number;
}

/** An active, registered participate in the consensus protocol, for a particular epoch. */
export interface ActiveStaker {
  /** The staker's registration.  If not provided, the StakingAddress is not associated with a StakingRegistration */
  registration:
    | StakingRegistration
    | undefined;
  /** the quantity of staked tokens for the epoch */
  quantity: number;
}

export interface LockAddress {
  /**
   * Base58 encoded
   * length = 32
   */
  value: string;
}

export interface Lock {
  ed25519?: Lock_Ed25519 | undefined;
}

export interface Lock_Ed25519 {
  /**
   * Base58 encoded
   * length = 32
   */
  vk: string;
}

export interface Key {
  ed25519?: Key_Ed25519 | undefined;
}

export interface Key_Ed25519 {
  /**
   * Base58 encoded
   * length = 64
   */
  signature: string;
}

export interface PeerId {
  /**
   * Base58 encoded
   * length = 32
   */
  value: string;
}

export interface PublicP2PState {
  localPeer: ConnectedPeer | undefined;
  peers: ConnectedPeer[];
}

export interface ConnectedPeer {
  peerId: PeerId | undefined;
  host: string | undefined;
  port: number | undefined;
}

function createBaseBlockId(): BlockId {
  return { value: "" };
}

export const BlockId = {
  encode(message: BlockId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockId {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: BlockId): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockId>, I>>(base?: I): BlockId {
    return BlockId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockId>, I>>(object: I): BlockId {
    const message = createBaseBlockId();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return {
    headerId: undefined,
    parentHeaderId: undefined,
    txRoot: "",
    timestamp: 0,
    height: 0,
    slot: 0,
    stakerCertificate: undefined,
    account: undefined,
    settings: {},
  };
}

export const BlockHeader = {
  encode(message: BlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headerId !== undefined) {
      BlockId.encode(message.headerId, writer.uint32(98).fork()).join();
    }
    if (message.parentHeaderId !== undefined) {
      BlockId.encode(message.parentHeaderId, writer.uint32(10).fork()).join();
    }
    if (message.txRoot !== "") {
      writer.uint32(26).string(message.txRoot);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).uint64(message.timestamp);
    }
    if (message.height !== 0) {
      writer.uint32(40).uint64(message.height);
    }
    if (message.slot !== 0) {
      writer.uint32(48).uint64(message.slot);
    }
    if (message.stakerCertificate !== undefined) {
      StakerCertificate.encode(message.stakerCertificate, writer.uint32(58).fork()).join();
    }
    if (message.account !== undefined) {
      TransactionOutputReference.encode(message.account, writer.uint32(66).fork()).join();
    }
    Object.entries(message.settings).forEach(([key, value]) => {
      BlockHeader_SettingsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.headerId = BlockId.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentHeaderId = BlockId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txRoot = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stakerCertificate = StakerCertificate.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.account = TransactionOutputReference.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = BlockHeader_SettingsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.settings[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      headerId: isSet(object.headerId) ? BlockId.fromJSON(object.headerId) : undefined,
      parentHeaderId: isSet(object.parentHeaderId) ? BlockId.fromJSON(object.parentHeaderId) : undefined,
      txRoot: isSet(object.txRoot) ? globalThis.String(object.txRoot) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      stakerCertificate: isSet(object.stakerCertificate)
        ? StakerCertificate.fromJSON(object.stakerCertificate)
        : undefined,
      account: isSet(object.account) ? TransactionOutputReference.fromJSON(object.account) : undefined,
      settings: isObject(object.settings)
        ? Object.entries(object.settings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.headerId !== undefined) {
      obj.headerId = BlockId.toJSON(message.headerId);
    }
    if (message.parentHeaderId !== undefined) {
      obj.parentHeaderId = BlockId.toJSON(message.parentHeaderId);
    }
    if (message.txRoot !== "") {
      obj.txRoot = message.txRoot;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.stakerCertificate !== undefined) {
      obj.stakerCertificate = StakerCertificate.toJSON(message.stakerCertificate);
    }
    if (message.account !== undefined) {
      obj.account = TransactionOutputReference.toJSON(message.account);
    }
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeader>, I>>(base?: I): BlockHeader {
    return BlockHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeader>, I>>(object: I): BlockHeader {
    const message = createBaseBlockHeader();
    message.headerId = (object.headerId !== undefined && object.headerId !== null)
      ? BlockId.fromPartial(object.headerId)
      : undefined;
    message.parentHeaderId = (object.parentHeaderId !== undefined && object.parentHeaderId !== null)
      ? BlockId.fromPartial(object.parentHeaderId)
      : undefined;
    message.txRoot = object.txRoot ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.height = object.height ?? 0;
    message.slot = object.slot ?? 0;
    message.stakerCertificate = (object.stakerCertificate !== undefined && object.stakerCertificate !== null)
      ? StakerCertificate.fromPartial(object.stakerCertificate)
      : undefined;
    message.account = (object.account !== undefined && object.account !== null)
      ? TransactionOutputReference.fromPartial(object.account)
      : undefined;
    message.settings = Object.entries(object.settings ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBlockHeader_SettingsEntry(): BlockHeader_SettingsEntry {
  return { key: "", value: "" };
}

export const BlockHeader_SettingsEntry = {
  encode(message: BlockHeader_SettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeader_SettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeader_SettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BlockHeader_SettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeader_SettingsEntry>, I>>(base?: I): BlockHeader_SettingsEntry {
    return BlockHeader_SettingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeader_SettingsEntry>, I>>(object: I): BlockHeader_SettingsEntry {
    const message = createBaseBlockHeader_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStakerCertificate(): StakerCertificate {
  return { blockSignature: "", vrfSignature: "", vrfVK: "", eta: "" };
}

export const StakerCertificate = {
  encode(message: StakerCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockSignature !== "") {
      writer.uint32(10).string(message.blockSignature);
    }
    if (message.vrfSignature !== "") {
      writer.uint32(18).string(message.vrfSignature);
    }
    if (message.vrfVK !== "") {
      writer.uint32(26).string(message.vrfVK);
    }
    if (message.eta !== "") {
      writer.uint32(42).string(message.eta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StakerCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStakerCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockSignature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vrfSignature = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vrfVK = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.eta = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StakerCertificate {
    return {
      blockSignature: isSet(object.blockSignature) ? globalThis.String(object.blockSignature) : "",
      vrfSignature: isSet(object.vrfSignature) ? globalThis.String(object.vrfSignature) : "",
      vrfVK: isSet(object.vrfVK) ? globalThis.String(object.vrfVK) : "",
      eta: isSet(object.eta) ? globalThis.String(object.eta) : "",
    };
  },

  toJSON(message: StakerCertificate): unknown {
    const obj: any = {};
    if (message.blockSignature !== "") {
      obj.blockSignature = message.blockSignature;
    }
    if (message.vrfSignature !== "") {
      obj.vrfSignature = message.vrfSignature;
    }
    if (message.vrfVK !== "") {
      obj.vrfVK = message.vrfVK;
    }
    if (message.eta !== "") {
      obj.eta = message.eta;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StakerCertificate>, I>>(base?: I): StakerCertificate {
    return StakerCertificate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StakerCertificate>, I>>(object: I): StakerCertificate {
    const message = createBaseStakerCertificate();
    message.blockSignature = object.blockSignature ?? "";
    message.vrfSignature = object.vrfSignature ?? "";
    message.vrfVK = object.vrfVK ?? "";
    message.eta = object.eta ?? "";
    return message;
  },
};

function createBaseSlotId(): SlotId {
  return { slot: 0, blockId: undefined };
}

export const SlotId = {
  encode(message: SlotId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slot !== 0) {
      writer.uint32(8).uint64(message.slot);
    }
    if (message.blockId !== undefined) {
      BlockId.encode(message.blockId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlotId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlotId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockId = BlockId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlotId {
    return {
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      blockId: isSet(object.blockId) ? BlockId.fromJSON(object.blockId) : undefined,
    };
  },

  toJSON(message: SlotId): unknown {
    const obj: any = {};
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.blockId !== undefined) {
      obj.blockId = BlockId.toJSON(message.blockId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlotId>, I>>(base?: I): SlotId {
    return SlotId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlotId>, I>>(object: I): SlotId {
    const message = createBaseSlotId();
    message.slot = object.slot ?? 0;
    message.blockId = (object.blockId !== undefined && object.blockId !== null)
      ? BlockId.fromPartial(object.blockId)
      : undefined;
    return message;
  },
};

function createBaseBlockBody(): BlockBody {
  return { transactionIds: [] };
}

export const BlockBody = {
  encode(message: BlockBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactionIds) {
      TransactionId.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionIds.push(TransactionId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockBody {
    return {
      transactionIds: globalThis.Array.isArray(object?.transactionIds)
        ? object.transactionIds.map((e: any) => TransactionId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockBody): unknown {
    const obj: any = {};
    if (message.transactionIds?.length) {
      obj.transactionIds = message.transactionIds.map((e) => TransactionId.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockBody>, I>>(base?: I): BlockBody {
    return BlockBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockBody>, I>>(object: I): BlockBody {
    const message = createBaseBlockBody();
    message.transactionIds = object.transactionIds?.map((e) => TransactionId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFullBlockBody(): FullBlockBody {
  return { transactions: [] };
}

export const FullBlockBody = {
  encode(message: FullBlockBody, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FullBlockBody {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFullBlockBody();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FullBlockBody {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FullBlockBody): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FullBlockBody>, I>>(base?: I): FullBlockBody {
    return FullBlockBody.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FullBlockBody>, I>>(object: I): FullBlockBody {
    const message = createBaseFullBlockBody();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlock(): Block {
  return { header: undefined, body: undefined };
}

export const Block = {
  encode(message: Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body !== undefined) {
      BlockBody.encode(message.body, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.body = BlockBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? BlockBody.fromJSON(object.body) : undefined,
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.body !== undefined) {
      obj.body = BlockBody.toJSON(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Block>, I>>(base?: I): Block {
    return Block.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Block>, I>>(object: I): Block {
    const message = createBaseBlock();
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.body = (object.body !== undefined && object.body !== null) ? BlockBody.fromPartial(object.body) : undefined;
    return message;
  },
};

function createBaseFullBlock(): FullBlock {
  return { header: undefined, fullBody: undefined };
}

export const FullBlock = {
  encode(message: FullBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      BlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.fullBody !== undefined) {
      FullBlockBody.encode(message.fullBody, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FullBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFullBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullBody = FullBlockBody.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FullBlock {
    return {
      header: isSet(object.header) ? BlockHeader.fromJSON(object.header) : undefined,
      fullBody: isSet(object.fullBody) ? FullBlockBody.fromJSON(object.fullBody) : undefined,
    };
  },

  toJSON(message: FullBlock): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = BlockHeader.toJSON(message.header);
    }
    if (message.fullBody !== undefined) {
      obj.fullBody = FullBlockBody.toJSON(message.fullBody);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FullBlock>, I>>(base?: I): FullBlock {
    return FullBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FullBlock>, I>>(object: I): FullBlock {
    const message = createBaseFullBlock();
    message.header = (object.header !== undefined && object.header !== null)
      ? BlockHeader.fromPartial(object.header)
      : undefined;
    message.fullBody = (object.fullBody !== undefined && object.fullBody !== null)
      ? FullBlockBody.fromPartial(object.fullBody)
      : undefined;
    return message;
  },
};

function createBaseTransactionId(): TransactionId {
  return { value: "" };
}

export const TransactionId = {
  encode(message: TransactionId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionId {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: TransactionId): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionId>, I>>(base?: I): TransactionId {
    return TransactionId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionId>, I>>(object: I): TransactionId {
    const message = createBaseTransactionId();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { transactionId: undefined, inputs: [], outputs: [], attestation: [], rewardParentBlockId: undefined };
}

export const Transaction = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== undefined) {
      TransactionId.encode(message.transactionId, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputs) {
      TransactionInput.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.outputs) {
      TransactionOutput.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.attestation) {
      Witness.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.rewardParentBlockId !== undefined) {
      BlockId.encode(message.rewardParentBlockId, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(TransactionInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputs.push(TransactionOutput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attestation.push(Witness.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rewardParentBlockId = BlockId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => TransactionInput.fromJSON(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => TransactionOutput.fromJSON(e))
        : [],
      attestation: globalThis.Array.isArray(object?.attestation)
        ? object.attestation.map((e: any) => Witness.fromJSON(e))
        : [],
      rewardParentBlockId: isSet(object.rewardParentBlockId) ? BlockId.fromJSON(object.rewardParentBlockId) : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.transactionId !== undefined) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => TransactionInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => TransactionOutput.toJSON(e));
    }
    if (message.attestation?.length) {
      obj.attestation = message.attestation.map((e) => Witness.toJSON(e));
    }
    if (message.rewardParentBlockId !== undefined) {
      obj.rewardParentBlockId = BlockId.toJSON(message.rewardParentBlockId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? TransactionId.fromPartial(object.transactionId)
      : undefined;
    message.inputs = object.inputs?.map((e) => TransactionInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => TransactionOutput.fromPartial(e)) || [];
    message.attestation = object.attestation?.map((e) => Witness.fromPartial(e)) || [];
    message.rewardParentBlockId = (object.rewardParentBlockId !== undefined && object.rewardParentBlockId !== null)
      ? BlockId.fromPartial(object.rewardParentBlockId)
      : undefined;
    return message;
  },
};

function createBaseTransactionConfirmation(): TransactionConfirmation {
  return { height: 0, depth: 0 };
}

export const TransactionConfirmation = {
  encode(message: TransactionConfirmation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).uint64(message.height);
    }
    if (message.depth !== 0) {
      writer.uint32(16).uint64(message.depth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionConfirmation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionConfirmation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.height = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.depth = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionConfirmation {
    return {
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
    };
  },

  toJSON(message: TransactionConfirmation): unknown {
    const obj: any = {};
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionConfirmation>, I>>(base?: I): TransactionConfirmation {
    return TransactionConfirmation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionConfirmation>, I>>(object: I): TransactionConfirmation {
    const message = createBaseTransactionConfirmation();
    message.height = object.height ?? 0;
    message.depth = object.depth ?? 0;
    return message;
  },
};

function createBaseWitness(): Witness {
  return { lockAddress: undefined, lock: undefined, key: undefined };
}

export const Witness = {
  encode(message: Witness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockAddress !== undefined) {
      LockAddress.encode(message.lockAddress, writer.uint32(26).fork()).join();
    }
    if (message.lock !== undefined) {
      Lock.encode(message.lock, writer.uint32(10).fork()).join();
    }
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Witness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lockAddress = LockAddress.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lock = Lock.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Witness {
    return {
      lockAddress: isSet(object.lockAddress) ? LockAddress.fromJSON(object.lockAddress) : undefined,
      lock: isSet(object.lock) ? Lock.fromJSON(object.lock) : undefined,
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
    };
  },

  toJSON(message: Witness): unknown {
    const obj: any = {};
    if (message.lockAddress !== undefined) {
      obj.lockAddress = LockAddress.toJSON(message.lockAddress);
    }
    if (message.lock !== undefined) {
      obj.lock = Lock.toJSON(message.lock);
    }
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Witness>, I>>(base?: I): Witness {
    return Witness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Witness>, I>>(object: I): Witness {
    const message = createBaseWitness();
    message.lockAddress = (object.lockAddress !== undefined && object.lockAddress !== null)
      ? LockAddress.fromPartial(object.lockAddress)
      : undefined;
    message.lock = (object.lock !== undefined && object.lock !== null) ? Lock.fromPartial(object.lock) : undefined;
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseTransactionInput(): TransactionInput {
  return { reference: undefined };
}

export const TransactionInput = {
  encode(message: TransactionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reference !== undefined) {
      TransactionOutputReference.encode(message.reference, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reference = TransactionOutputReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInput {
    return { reference: isSet(object.reference) ? TransactionOutputReference.fromJSON(object.reference) : undefined };
  },

  toJSON(message: TransactionInput): unknown {
    const obj: any = {};
    if (message.reference !== undefined) {
      obj.reference = TransactionOutputReference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInput>, I>>(base?: I): TransactionInput {
    return TransactionInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInput>, I>>(object: I): TransactionInput {
    const message = createBaseTransactionInput();
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? TransactionOutputReference.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseTransactionOutputReference(): TransactionOutputReference {
  return { transactionId: undefined, index: 0 };
}

export const TransactionOutputReference = {
  encode(message: TransactionOutputReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== undefined) {
      TransactionId.encode(message.transactionId, writer.uint32(10).fork()).join();
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOutputReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOutputReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionId = TransactionId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOutputReference {
    return {
      transactionId: isSet(object.transactionId) ? TransactionId.fromJSON(object.transactionId) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: TransactionOutputReference): unknown {
    const obj: any = {};
    if (message.transactionId !== undefined) {
      obj.transactionId = TransactionId.toJSON(message.transactionId);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionOutputReference>, I>>(base?: I): TransactionOutputReference {
    return TransactionOutputReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionOutputReference>, I>>(object: I): TransactionOutputReference {
    const message = createBaseTransactionOutputReference();
    message.transactionId = (object.transactionId !== undefined && object.transactionId !== null)
      ? TransactionId.fromPartial(object.transactionId)
      : undefined;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseTransactionOutput(): TransactionOutput {
  return {
    lockAddress: undefined,
    quantity: 0,
    account: undefined,
    graphEntry: undefined,
    accountRegistration: undefined,
    asset: undefined,
  };
}

export const TransactionOutput = {
  encode(message: TransactionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockAddress !== undefined) {
      LockAddress.encode(message.lockAddress, writer.uint32(10).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint64(message.quantity);
    }
    if (message.account !== undefined) {
      TransactionOutputReference.encode(message.account, writer.uint32(26).fork()).join();
    }
    if (message.graphEntry !== undefined) {
      GraphEntry.encode(message.graphEntry, writer.uint32(42).fork()).join();
    }
    if (message.accountRegistration !== undefined) {
      AccountRegistration.encode(message.accountRegistration, writer.uint32(50).fork()).join();
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lockAddress = LockAddress.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.uint64());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.account = TransactionOutputReference.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.graphEntry = GraphEntry.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accountRegistration = AccountRegistration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionOutput {
    return {
      lockAddress: isSet(object.lockAddress) ? LockAddress.fromJSON(object.lockAddress) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      account: isSet(object.account) ? TransactionOutputReference.fromJSON(object.account) : undefined,
      graphEntry: isSet(object.graphEntry) ? GraphEntry.fromJSON(object.graphEntry) : undefined,
      accountRegistration: isSet(object.accountRegistration)
        ? AccountRegistration.fromJSON(object.accountRegistration)
        : undefined,
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: TransactionOutput): unknown {
    const obj: any = {};
    if (message.lockAddress !== undefined) {
      obj.lockAddress = LockAddress.toJSON(message.lockAddress);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.account !== undefined) {
      obj.account = TransactionOutputReference.toJSON(message.account);
    }
    if (message.graphEntry !== undefined) {
      obj.graphEntry = GraphEntry.toJSON(message.graphEntry);
    }
    if (message.accountRegistration !== undefined) {
      obj.accountRegistration = AccountRegistration.toJSON(message.accountRegistration);
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionOutput>, I>>(base?: I): TransactionOutput {
    return TransactionOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionOutput>, I>>(object: I): TransactionOutput {
    const message = createBaseTransactionOutput();
    message.lockAddress = (object.lockAddress !== undefined && object.lockAddress !== null)
      ? LockAddress.fromPartial(object.lockAddress)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.account = (object.account !== undefined && object.account !== null)
      ? TransactionOutputReference.fromPartial(object.account)
      : undefined;
    message.graphEntry = (object.graphEntry !== undefined && object.graphEntry !== null)
      ? GraphEntry.fromPartial(object.graphEntry)
      : undefined;
    message.accountRegistration = (object.accountRegistration !== undefined && object.accountRegistration !== null)
      ? AccountRegistration.fromPartial(object.accountRegistration)
      : undefined;
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    return message;
  },
};

function createBaseAccountRegistration(): AccountRegistration {
  return { associationLock: undefined, stakingRegistration: undefined };
}

export const AccountRegistration = {
  encode(message: AccountRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.associationLock !== undefined) {
      LockAddress.encode(message.associationLock, writer.uint32(10).fork()).join();
    }
    if (message.stakingRegistration !== undefined) {
      StakingRegistration.encode(message.stakingRegistration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.associationLock = LockAddress.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stakingRegistration = StakingRegistration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountRegistration {
    return {
      associationLock: isSet(object.associationLock) ? LockAddress.fromJSON(object.associationLock) : undefined,
      stakingRegistration: isSet(object.stakingRegistration)
        ? StakingRegistration.fromJSON(object.stakingRegistration)
        : undefined,
    };
  },

  toJSON(message: AccountRegistration): unknown {
    const obj: any = {};
    if (message.associationLock !== undefined) {
      obj.associationLock = LockAddress.toJSON(message.associationLock);
    }
    if (message.stakingRegistration !== undefined) {
      obj.stakingRegistration = StakingRegistration.toJSON(message.stakingRegistration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountRegistration>, I>>(base?: I): AccountRegistration {
    return AccountRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountRegistration>, I>>(object: I): AccountRegistration {
    const message = createBaseAccountRegistration();
    message.associationLock = (object.associationLock !== undefined && object.associationLock !== null)
      ? LockAddress.fromPartial(object.associationLock)
      : undefined;
    message.stakingRegistration = (object.stakingRegistration !== undefined && object.stakingRegistration !== null)
      ? StakingRegistration.fromPartial(object.stakingRegistration)
      : undefined;
    return message;
  },
};

function createBaseStakingRegistration(): StakingRegistration {
  return { commitmentSignature: "", vk: "" };
}

export const StakingRegistration = {
  encode(message: StakingRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commitmentSignature !== "") {
      writer.uint32(10).string(message.commitmentSignature);
    }
    if (message.vk !== "") {
      writer.uint32(18).string(message.vk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StakingRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStakingRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commitmentSignature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vk = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StakingRegistration {
    return {
      commitmentSignature: isSet(object.commitmentSignature) ? globalThis.String(object.commitmentSignature) : "",
      vk: isSet(object.vk) ? globalThis.String(object.vk) : "",
    };
  },

  toJSON(message: StakingRegistration): unknown {
    const obj: any = {};
    if (message.commitmentSignature !== "") {
      obj.commitmentSignature = message.commitmentSignature;
    }
    if (message.vk !== "") {
      obj.vk = message.vk;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StakingRegistration>, I>>(base?: I): StakingRegistration {
    return StakingRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StakingRegistration>, I>>(object: I): StakingRegistration {
    const message = createBaseStakingRegistration();
    message.commitmentSignature = object.commitmentSignature ?? "";
    message.vk = object.vk ?? "";
    return message;
  },
};

function createBaseGraphEntry(): GraphEntry {
  return { vertex: undefined, edge: undefined };
}

export const GraphEntry = {
  encode(message: GraphEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vertex !== undefined) {
      Vertex.encode(message.vertex, writer.uint32(10).fork()).join();
    }
    if (message.edge !== undefined) {
      Edge.encode(message.edge, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertex = Vertex.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.edge = Edge.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphEntry {
    return {
      vertex: isSet(object.vertex) ? Vertex.fromJSON(object.vertex) : undefined,
      edge: isSet(object.edge) ? Edge.fromJSON(object.edge) : undefined,
    };
  },

  toJSON(message: GraphEntry): unknown {
    const obj: any = {};
    if (message.vertex !== undefined) {
      obj.vertex = Vertex.toJSON(message.vertex);
    }
    if (message.edge !== undefined) {
      obj.edge = Edge.toJSON(message.edge);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphEntry>, I>>(base?: I): GraphEntry {
    return GraphEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphEntry>, I>>(object: I): GraphEntry {
    const message = createBaseGraphEntry();
    message.vertex = (object.vertex !== undefined && object.vertex !== null)
      ? Vertex.fromPartial(object.vertex)
      : undefined;
    message.edge = (object.edge !== undefined && object.edge !== null) ? Edge.fromPartial(object.edge) : undefined;
    return message;
  },
};

function createBaseVertex(): Vertex {
  return { label: "", data: undefined, edgeLockAddress: undefined };
}

export const Vertex = {
  encode(message: Vertex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).join();
    }
    if (message.edgeLockAddress !== undefined) {
      LockAddress.encode(message.edgeLockAddress, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vertex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.edgeLockAddress = LockAddress.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vertex {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      data: isObject(object.data) ? object.data : undefined,
      edgeLockAddress: isSet(object.edgeLockAddress) ? LockAddress.fromJSON(object.edgeLockAddress) : undefined,
    };
  },

  toJSON(message: Vertex): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.edgeLockAddress !== undefined) {
      obj.edgeLockAddress = LockAddress.toJSON(message.edgeLockAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vertex>, I>>(base?: I): Vertex {
    return Vertex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vertex>, I>>(object: I): Vertex {
    const message = createBaseVertex();
    message.label = object.label ?? "";
    message.data = object.data ?? undefined;
    message.edgeLockAddress = (object.edgeLockAddress !== undefined && object.edgeLockAddress !== null)
      ? LockAddress.fromPartial(object.edgeLockAddress)
      : undefined;
    return message;
  },
};

function createBaseEdge(): Edge {
  return { label: "", data: undefined, a: undefined, b: undefined };
}

export const Edge = {
  encode(message: Edge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).join();
    }
    if (message.a !== undefined) {
      TransactionOutputReference.encode(message.a, writer.uint32(26).fork()).join();
    }
    if (message.b !== undefined) {
      TransactionOutputReference.encode(message.b, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Edge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.a = TransactionOutputReference.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.b = TransactionOutputReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      data: isObject(object.data) ? object.data : undefined,
      a: isSet(object.a) ? TransactionOutputReference.fromJSON(object.a) : undefined,
      b: isSet(object.b) ? TransactionOutputReference.fromJSON(object.b) : undefined,
    };
  },

  toJSON(message: Edge): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.a !== undefined) {
      obj.a = TransactionOutputReference.toJSON(message.a);
    }
    if (message.b !== undefined) {
      obj.b = TransactionOutputReference.toJSON(message.b);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Edge>, I>>(base?: I): Edge {
    return Edge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Edge>, I>>(object: I): Edge {
    const message = createBaseEdge();
    message.label = object.label ?? "";
    message.data = object.data ?? undefined;
    message.a = (object.a !== undefined && object.a !== null)
      ? TransactionOutputReference.fromPartial(object.a)
      : undefined;
    message.b = (object.b !== undefined && object.b !== null)
      ? TransactionOutputReference.fromPartial(object.b)
      : undefined;
    return message;
  },
};

function createBaseAsset(): Asset {
  return { origin: undefined, quantity: 0 };
}

export const Asset = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.origin !== undefined) {
      TransactionOutputReference.encode(message.origin, writer.uint32(10).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint64(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = TransactionOutputReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.uint64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      origin: isSet(object.origin) ? TransactionOutputReference.fromJSON(object.origin) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = TransactionOutputReference.toJSON(message.origin);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? TransactionOutputReference.fromPartial(object.origin)
      : undefined;
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseActiveStaker(): ActiveStaker {
  return { registration: undefined, quantity: 0 };
}

export const ActiveStaker = {
  encode(message: ActiveStaker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== undefined) {
      StakingRegistration.encode(message.registration, writer.uint32(10).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveStaker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveStaker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = StakingRegistration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveStaker {
    return {
      registration: isSet(object.registration) ? StakingRegistration.fromJSON(object.registration) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: ActiveStaker): unknown {
    const obj: any = {};
    if (message.registration !== undefined) {
      obj.registration = StakingRegistration.toJSON(message.registration);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActiveStaker>, I>>(base?: I): ActiveStaker {
    return ActiveStaker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActiveStaker>, I>>(object: I): ActiveStaker {
    const message = createBaseActiveStaker();
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? StakingRegistration.fromPartial(object.registration)
      : undefined;
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseLockAddress(): LockAddress {
  return { value: "" };
}

export const LockAddress = {
  encode(message: LockAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockAddress {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: LockAddress): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockAddress>, I>>(base?: I): LockAddress {
    return LockAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockAddress>, I>>(object: I): LockAddress {
    const message = createBaseLockAddress();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLock(): Lock {
  return { ed25519: undefined };
}

export const Lock = {
  encode(message: Lock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ed25519 !== undefined) {
      Lock_Ed25519.encode(message.ed25519, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ed25519 = Lock_Ed25519.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lock {
    return { ed25519: isSet(object.ed25519) ? Lock_Ed25519.fromJSON(object.ed25519) : undefined };
  },

  toJSON(message: Lock): unknown {
    const obj: any = {};
    if (message.ed25519 !== undefined) {
      obj.ed25519 = Lock_Ed25519.toJSON(message.ed25519);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lock>, I>>(base?: I): Lock {
    return Lock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lock>, I>>(object: I): Lock {
    const message = createBaseLock();
    message.ed25519 = (object.ed25519 !== undefined && object.ed25519 !== null)
      ? Lock_Ed25519.fromPartial(object.ed25519)
      : undefined;
    return message;
  },
};

function createBaseLock_Ed25519(): Lock_Ed25519 {
  return { vk: "" };
}

export const Lock_Ed25519 = {
  encode(message: Lock_Ed25519, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vk !== "") {
      writer.uint32(10).string(message.vk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lock_Ed25519 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLock_Ed25519();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vk = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lock_Ed25519 {
    return { vk: isSet(object.vk) ? globalThis.String(object.vk) : "" };
  },

  toJSON(message: Lock_Ed25519): unknown {
    const obj: any = {};
    if (message.vk !== "") {
      obj.vk = message.vk;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lock_Ed25519>, I>>(base?: I): Lock_Ed25519 {
    return Lock_Ed25519.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lock_Ed25519>, I>>(object: I): Lock_Ed25519 {
    const message = createBaseLock_Ed25519();
    message.vk = object.vk ?? "";
    return message;
  },
};

function createBaseKey(): Key {
  return { ed25519: undefined };
}

export const Key = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ed25519 !== undefined) {
      Key_Ed25519.encode(message.ed25519, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ed25519 = Key_Ed25519.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return { ed25519: isSet(object.ed25519) ? Key_Ed25519.fromJSON(object.ed25519) : undefined };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.ed25519 !== undefined) {
      obj.ed25519 = Key_Ed25519.toJSON(message.ed25519);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Key>, I>>(base?: I): Key {
    return Key.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Key>, I>>(object: I): Key {
    const message = createBaseKey();
    message.ed25519 = (object.ed25519 !== undefined && object.ed25519 !== null)
      ? Key_Ed25519.fromPartial(object.ed25519)
      : undefined;
    return message;
  },
};

function createBaseKey_Ed25519(): Key_Ed25519 {
  return { signature: "" };
}

export const Key_Ed25519 = {
  encode(message: Key_Ed25519, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key_Ed25519 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey_Ed25519();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key_Ed25519 {
    return { signature: isSet(object.signature) ? globalThis.String(object.signature) : "" };
  },

  toJSON(message: Key_Ed25519): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Key_Ed25519>, I>>(base?: I): Key_Ed25519 {
    return Key_Ed25519.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Key_Ed25519>, I>>(object: I): Key_Ed25519 {
    const message = createBaseKey_Ed25519();
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBasePeerId(): PeerId {
  return { value: "" };
}

export const PeerId = {
  encode(message: PeerId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeerId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeerId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeerId {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: PeerId): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PeerId>, I>>(base?: I): PeerId {
    return PeerId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PeerId>, I>>(object: I): PeerId {
    const message = createBasePeerId();
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePublicP2PState(): PublicP2PState {
  return { localPeer: undefined, peers: [] };
}

export const PublicP2PState = {
  encode(message: PublicP2PState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localPeer !== undefined) {
      ConnectedPeer.encode(message.localPeer, writer.uint32(10).fork()).join();
    }
    for (const v of message.peers) {
      ConnectedPeer.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicP2PState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicP2PState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.localPeer = ConnectedPeer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.peers.push(ConnectedPeer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicP2PState {
    return {
      localPeer: isSet(object.localPeer) ? ConnectedPeer.fromJSON(object.localPeer) : undefined,
      peers: globalThis.Array.isArray(object?.peers) ? object.peers.map((e: any) => ConnectedPeer.fromJSON(e)) : [],
    };
  },

  toJSON(message: PublicP2PState): unknown {
    const obj: any = {};
    if (message.localPeer !== undefined) {
      obj.localPeer = ConnectedPeer.toJSON(message.localPeer);
    }
    if (message.peers?.length) {
      obj.peers = message.peers.map((e) => ConnectedPeer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublicP2PState>, I>>(base?: I): PublicP2PState {
    return PublicP2PState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicP2PState>, I>>(object: I): PublicP2PState {
    const message = createBasePublicP2PState();
    message.localPeer = (object.localPeer !== undefined && object.localPeer !== null)
      ? ConnectedPeer.fromPartial(object.localPeer)
      : undefined;
    message.peers = object.peers?.map((e) => ConnectedPeer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConnectedPeer(): ConnectedPeer {
  return { peerId: undefined, host: undefined, port: undefined };
}

export const ConnectedPeer = {
  encode(message: ConnectedPeer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerId !== undefined) {
      PeerId.encode(message.peerId, writer.uint32(10).fork()).join();
    }
    if (message.host !== undefined) {
      StringValue.encode({ value: message.host! }, writer.uint32(18).fork()).join();
    }
    if (message.port !== undefined) {
      UInt32Value.encode({ value: message.port! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectedPeer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectedPeer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peerId = PeerId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.port = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectedPeer {
    return {
      peerId: isSet(object.peerId) ? PeerId.fromJSON(object.peerId) : undefined,
      host: isSet(object.host) ? String(object.host) : undefined,
      port: isSet(object.port) ? Number(object.port) : undefined,
    };
  },

  toJSON(message: ConnectedPeer): unknown {
    const obj: any = {};
    if (message.peerId !== undefined) {
      obj.peerId = PeerId.toJSON(message.peerId);
    }
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.port !== undefined) {
      obj.port = message.port;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectedPeer>, I>>(base?: I): ConnectedPeer {
    return ConnectedPeer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectedPeer>, I>>(object: I): ConnectedPeer {
    const message = createBaseConnectedPeer();
    message.peerId = (object.peerId !== undefined && object.peerId !== null)
      ? PeerId.fromPartial(object.peerId)
      : undefined;
    message.host = object.host ?? undefined;
    message.port = object.port ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
